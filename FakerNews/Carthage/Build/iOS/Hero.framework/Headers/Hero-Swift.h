// Generated by Apple Swift version 3.0.2 (swiftlang-800.0.63 clang-800.0.42.1)
#pragma clang diagnostic push

#if defined(__has_include) && __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#include <objc/NSObject.h>
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if defined(__has_include) && __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus) || __cplusplus < 201103L
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...)
# endif
#endif

#if defined(__has_attribute) && __has_attribute(objc_runtime_name)
# define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
#else
# define SWIFT_RUNTIME_NAME(X)
#endif
#if defined(__has_attribute) && __has_attribute(swift_name)
# define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
#else
# define SWIFT_COMPILE_NAME(X)
#endif
#if defined(__has_attribute) && __has_attribute(objc_method_family)
# define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
#else
# define SWIFT_METHOD_FAMILY(X)
#endif
#if defined(__has_attribute) && __has_attribute(noescape)
# define SWIFT_NOESCAPE __attribute__((noescape))
#else
# define SWIFT_NOESCAPE
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA
#endif
#if !defined(SWIFT_CLASS)
# if defined(__has_attribute) && __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif

#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif

#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif

#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if defined(__has_attribute) && __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name) enum _name : _type _name; enum SWIFT_ENUM_EXTRA _name : _type
# if defined(__has_feature) && __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME) SWIFT_ENUM(_type, _name)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if defined(__has_feature) && __has_feature(modules)
@import QuartzCore;
@import ObjectiveC;
@import UIKit;
@import Foundation;
@import CoreGraphics;
#endif

#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"

@interface CALayer (SWIFT_EXTENSION(Hero))
@end


@interface CAMediaTimingFunction (SWIFT_EXTENSION(Hero))
@end

@class UIView;
@class UIViewController;

SWIFT_CLASS("_TtC4Hero4Hero")
@interface Hero : NSObject
/**
  <h2>The Singleton object for controlling interactive transitions.</h2>
  \code
  var presenting:Bool
  var interactive:Bool

  \endcode<h3>Use the following methods for controlling the interactive transition:</h3>
  \code
  func update(progress:Double)
  func end()
  func cancel()
  func apply(modifiers:[HeroModifier], to view:UIView)

  \endcode*/
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) Hero * _Nonnull shared;)
+ (Hero * _Nonnull)shared;
@property (nonatomic, readonly, weak) UIViewController * _Nullable toViewController;
@property (nonatomic, readonly, weak) UIViewController * _Nullable fromViewController;
@property (nonatomic, readonly) BOOL presenting;
@property (nonatomic, readonly) BOOL interactive;
@property (nonatomic, readonly) double progress;
@property (nonatomic, readonly) BOOL transitioning;
@property (nonatomic, readonly, strong) UIView * _Null_unspecified container;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
@end


@interface Hero (SWIFT_EXTENSION(Hero))
@end


@interface Hero (SWIFT_EXTENSION(Hero))
@end

@class UITabBarController;
@protocol UIViewControllerAnimatedTransitioning;
@protocol UIViewControllerInteractiveTransitioning;

@interface Hero (SWIFT_EXTENSION(Hero)) <UITabBarControllerDelegate>
- (id <UIViewControllerInteractiveTransitioning> _Nullable)tabBarController:(UITabBarController * _Nonnull)tabBarController interactionControllerForAnimationController:(id <UIViewControllerAnimatedTransitioning> _Nonnull)animationController;
- (id <UIViewControllerAnimatedTransitioning> _Nullable)tabBarController:(UITabBarController * _Nonnull)tabBarController animationControllerForTransitionFromViewController:(UIViewController * _Nonnull)fromVC toViewController:(UIViewController * _Nonnull)toVC;
@end

@class UINavigationController;

@interface Hero (SWIFT_EXTENSION(Hero)) <UINavigationControllerDelegate>
- (id <UIViewControllerAnimatedTransitioning> _Nullable)navigationController:(UINavigationController * _Nonnull)navigationController animationControllerForOperation:(UINavigationControllerOperation)operation fromViewController:(UIViewController * _Nonnull)fromVC toViewController:(UIViewController * _Nonnull)toVC;
- (id <UIViewControllerInteractiveTransitioning> _Nullable)navigationController:(UINavigationController * _Nonnull)navigationController interactionControllerForAnimationController:(id <UIViewControllerAnimatedTransitioning> _Nonnull)animationController;
@end

@protocol UIViewControllerContextTransitioning;

@interface Hero (SWIFT_EXTENSION(Hero)) <UIViewControllerAnimatedTransitioning>
- (void)animateTransition:(id <UIViewControllerContextTransitioning> _Nonnull)context;
- (NSTimeInterval)transitionDuration:(id <UIViewControllerContextTransitioning> _Nullable)transitionContext;
@end


@interface Hero (SWIFT_EXTENSION(Hero))
@end


@interface Hero (SWIFT_EXTENSION(Hero))
@end


@interface Hero (SWIFT_EXTENSION(Hero))
/**
  Update the progress for the interactive transition.
  \param progress the current progress, must be between 0â€¦1

*/
- (void)updateWithProgress:(double)progress;
/**
  Finish the interactive transition.
  Will stop the interactive transition and animate from the
  current state to the <em>end</em> state
*/
- (void)end;
/**
  Cancel the interactive transition.
  Will stop the interactive transition and animate from the
  current state to the <em>begining</em> state
*/
- (void)cancel;
@end


@interface Hero (SWIFT_EXTENSION(Hero)) <UIViewControllerInteractiveTransitioning>
@property (nonatomic, readonly) BOOL wantsInteractiveStart;
- (void)startInteractiveTransition:(id <UIViewControllerContextTransitioning> _Nonnull)transitionContext;
@end


@interface Hero (SWIFT_EXTENSION(Hero)) <UIViewControllerTransitioningDelegate>
- (id <UIViewControllerAnimatedTransitioning> _Nullable)animationControllerForPresentedController:(UIViewController * _Nonnull)presented presentingController:(UIViewController * _Nonnull)presenting sourceController:(UIViewController * _Nonnull)source;
- (id <UIViewControllerAnimatedTransitioning> _Nullable)animationControllerForDismissedController:(UIViewController * _Nonnull)dismissed;
- (id <UIViewControllerInteractiveTransitioning> _Nullable)interactionControllerForDismissal:(id <UIViewControllerAnimatedTransitioning> _Nonnull)animator;
- (id <UIViewControllerInteractiveTransitioning> _Nullable)interactionControllerForPresentation:(id <UIViewControllerAnimatedTransitioning> _Nonnull)animator;
@end


SWIFT_CLASS("_TtC4Hero10HeroPlugin")
@interface HeroPlugin : NSObject
/**
  Determines whether or not to receive \code
  seekTo
  \endcode callback on every frame.
  Default is false.
  When <em>requirePerFrameCallback</em> is <em>false</em>, the plugin needs to start its own animations inside \code
  animate
  \endcode & \code
  resume
  \endcode
  The \code
  seekTo
  \endcode method is only being called during an interactive transition.
  When <em>requirePerFrameCallback</em> is <em>true</em>, the plugin will receive \code
  seekTo
  \endcode callback on every animation frame. Hence it is possible for the plugin to do per-frame animations without implementing \code
  animate
  \endcode & \code
  resume
  \endcode
*/
@property (nonatomic) BOOL requirePerFrameCallback;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
/**
  Called before any animation.
  Override this method when you want to preprocess modifiers for views
  To check a viewâ€™s modifiers:
  \code
  context[view]
  context[view, "modifierName"]

  \endcodeTo set a viewâ€™s modifiers:
  \code
  context[view] = [("modifier1", ["parameter1"]), ("modifier2", [])]
  context[view, "modifier1"] = ["parameter1", "parameter2"]

  \endcode\param context object holding all parsed and changed modifiers,

  \param fromViews A flattened list of all views from source ViewController

  \param toViews A flattened list of all views from destination ViewController

*/
- (void)processFromViews:(NSArray<UIView *> * _Nonnull)fromViews toViews:(NSArray<UIView *> * _Nonnull)toViews;
/**
  \param context object holding all parsed and changed modifiers,

  \param view the view to check whether or not the plugin can handle the animation

  \param appearing true if the view is appearing(i.e. a view in destination ViewController)
  If return true, Hero wonâ€™t animate and wonâ€™t let any other plugins animate this view.
  The view will also be hidden automatically during the animation.


  returns:
  return true if the plugin can handle animating the view.
*/
- (BOOL)canAnimateWithView:(UIView * _Nonnull)view appearing:(BOOL)appearing;
/**
  Perform the animation.
  Note: views in \code
  fromViews
  \endcode & \code
  toViews
  \endcode are hidden already. Unhide then if you need to take snapshots.
  \param context object holding all parsed and changed modifiers,

  \param fromViews A flattened list of all views from source ViewController (filtered by \code
  canAnimate
  \endcode)

  \param toViews A flattened list of all views from destination ViewController (filtered by \code
  canAnimate
  \endcode)


  returns:
  The duration needed to complete the animation
*/
- (NSTimeInterval)animateFromViews:(NSArray<UIView *> * _Nonnull)fromViews toViews:(NSArray<UIView *> * _Nonnull)toViews;
/**
  Called when all animations are completed.
  Should perform cleanup and release any reference
*/
- (void)clean;
/**
  For supporting interactive animation only.
  This method is called when an interactive animation is in place
  The plugin should pause the animation, and seek to the given progress
  \param timePassed time of the animation to seek to.

*/
- (void)seekToTimePassed:(NSTimeInterval)timePassed;
/**
  For supporting interactive animation only.
  This method is called when an interactive animation is ended
  The plugin should resume the animation.
  <ul>
    <li>
      Parameters:
    </li>
    <li>
      timePassed: will be the same value since last \code
      seekTo
      \endcode
    </li>
    <li>
      reverse: a boolean value indicating whether or not the animation should reverse
    </li>
  </ul>
*/
- (NSTimeInterval)resumeWithTimePassed:(NSTimeInterval)timePassed reverse:(BOOL)reverse;
@end


SWIFT_CLASS("_TtC4Hero15HeroDebugPlugin")
@interface HeroDebugPlugin : HeroPlugin
- (NSTimeInterval)animateFromViews:(NSArray<UIView *> * _Nonnull)fromViews toViews:(NSArray<UIView *> * _Nonnull)toViews;
- (NSTimeInterval)resumeWithTimePassed:(NSTimeInterval)timePassed reverse:(BOOL)reverse;
- (void)clean;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


@interface HeroDebugPlugin (SWIFT_EXTENSION(Hero))
- (void)onDone;
- (void)onProcessSliderChangedWithProgress:(float)progress;
@end

@class NSCoder;

SWIFT_CLASS("_TtC4Hero13HeroDebugView")
@interface HeroDebugView : UIView
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
- (void)layoutSubviews;
- (void)pan;
- (void)pinch;
- (void)onDone;
- (void)onPerspective;
- (void)onDisplayArcCurve;
- (void)onSlide;
- (nonnull instancetype)initWithFrame:(CGRect)frame SWIFT_UNAVAILABLE;
@end

@class UIGestureRecognizer;

@interface HeroDebugView (SWIFT_EXTENSION(Hero)) <UIGestureRecognizerDelegate>
- (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer * _Nonnull)gestureRecognizer;
@end



@interface HeroPlugin (SWIFT_EXTENSION(Hero))
SWIFT_CLASS_PROPERTY(@property (nonatomic, class) BOOL isEnabled;)
+ (BOOL)isEnabled;
+ (void)setIsEnabled:(BOOL)newValue;
+ (void)enable;
+ (void)disable;
@end


SWIFT_PROTOCOL("_TtP4Hero26HeroViewControllerDelegate_")
@protocol HeroViewControllerDelegate
@optional
- (void)heroWillStartAnimatingFromViewController:(UIViewController * _Nonnull)viewController;
- (void)heroDidEndAnimatingFromViewController:(UIViewController * _Nonnull)viewController;
- (void)heroWillStartTransition;
- (void)heroDidEndTransition;
- (void)heroWillStartAnimatingToViewController:(UIViewController * _Nonnull)viewController;
- (void)heroDidEndAnimatingToViewController:(UIViewController * _Nonnull)viewController;
@end


@interface NSObject (SWIFT_EXTENSION(Hero))
@end


@interface UIImage (SWIFT_EXTENSION(Hero))
@end


@interface UIView (SWIFT_EXTENSION(Hero))
@property (nonatomic, copy) NSString * _Nullable heroID;
@property (nonatomic, copy) NSString * _Nullable heroModifierString;
- (UIView * _Nonnull)slowSnapshotView;
@end


@interface UIViewController (SWIFT_EXTENSION(Hero))
@property (nonatomic, strong) id <UINavigationControllerDelegate> _Nullable previousNavigationDelegate;
@property (nonatomic, strong) id <UITabBarControllerDelegate> _Nullable previousTabBarDelegate;
@property (nonatomic) BOOL isHeroEnabled;
- (IBAction)ht_dismiss:(UIView * _Nonnull)sender;
- (void)heroReplaceViewControllerWith:(UIViewController * _Nonnull)next;
@end

#pragma clang diagnostic pop
